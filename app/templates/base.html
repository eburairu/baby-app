<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}Baby-App{% endblock %}</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#2563eb',   // blue-600
                        secondary: '#16a34a', // green-600
                    }
                }
            }
        }
    </script>

    <!-- htmx -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>

    <!-- カスタムCSS -->
    <link rel="stylesheet" href="/static/css/custom.css">

    <script>
        // ダークモード初期化
        if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
    </script>
</head>

<body class="bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-gray-100">
    {% if user %}
    {% include "components/navbar.html" %}
    {% endif %}

    <main class="{% if user %}container mx-auto px-3 md:px-4 py-4 md:py-8 pb-20 md:pb-8{% endif %}">
        {% block content %}{% endblock %}
    </main>

    <!-- トースト通知コンテナ -->
    <div id="toast-container" class="fixed bottom-20 md:bottom-5 right-5 z-50 flex flex-col gap-2"></div>

    <!-- ローディングオーバーレイ (育児モード) -->
    <div id="loading-overlay" class="loading-overlay">
        <div class="flex flex-col items-center">
            <!-- 哺乳瓶アイコン -->
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-20 h-20 text-blue-500 animate-baby-rocking mb-4 filter drop-shadow-lg">
                <path d="M16.5 6h-1.5V4.5a1.5 1.5 0 0 0-3 0V6H10.5a1.5 1.5 0 0 0 0 3h6a1.5 1.5 0 0 0 0-3Z" opacity="0.5"/>
                <path d="M9 10.5V20.25c0 1.243 1.007 2.25 2.25 2.25h4.5c1.243 0 2.25-1.007 2.25-2.25V10.5a.75.75 0 0 0-.75-.75H9.75a.75.75 0 0 0-.75.75Z" />
                <path d="M12 2.25a.75.75 0 0 1 .75.75v1.5h-1.5V3a.75.75 0 0 1 .75-.75Z" />
            </svg>
            <span class="text-xl font-bold text-gray-600 dark:text-gray-300 tracking-wider">Loading...</span>
        </div>
    </div>

    <script>
        // ダークモード切り替え
        function toggleTheme() {
            if (document.documentElement.classList.contains('dark')) {
                document.documentElement.classList.remove('dark');
                localStorage.theme = 'light';
            } else {
                document.documentElement.classList.add('dark');
                localStorage.theme = 'dark';
            }
        }

        // トースト表示関数
        function showToast(message, type = 'error') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            const bgColor = type === 'error' ? 'bg-red-500' : 'bg-green-500';
            
            toast.className = `${bgColor} text-white px-6 py-3 rounded-lg shadow-lg transition-opacity duration-300 opacity-0`;
            toast.textContent = message;
            
            container.appendChild(toast);
            
            // アニメーション表示
            setTimeout(() => toast.classList.remove('opacity-0'), 10);
            
            // 3秒後に削除
            setTimeout(() => {
                toast.classList.add('opacity-0');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        // ローディングオーバーレイ制御
        const loadingOverlay = document.getElementById('loading-overlay');

        // HTMX リクエスト開始
        document.body.addEventListener('htmx:configRequest', function() {
            loadingOverlay.classList.add('active');
        });

        // HTMX リクエスト完了 (成功/失敗問わず)
        document.body.addEventListener('htmx:afterRequest', function() {
            // 少し遅延させて、早すぎる点滅を防ぐ（オプション）
            setTimeout(() => {
                loadingOverlay.classList.remove('active');
            }, 300);
        });

        // 通常のフォーム送信
        document.addEventListener('submit', function(e) {
            // HTMX経由のフォームは htmx:configRequest で処理されるので除外する必要があるが、
            // HTMXが処理する場合 e.defaultPrevented が true になることが多い。
            // あるいは、hx-boostなどでシームレスに処理される場合もある。
            // ここでは、明示的に form 要素からの submit で、かつ htmx 属性がない、あるいは
            // HTMXが処理しない場合を想定したいが、
            // シンプルに「送信ボタンを押したら出す」で、HTMXの場合は二重に出ても問題ない（同じIDなので）。
            // ただし、バリデーションエラーなどで送信がキャンセルされた場合は消す必要がある。
            
            // target="_blank" や download 属性がある場合は表示しない
            if (e.target.target === '_blank' || e.target.hasAttribute('download')) {
                return;
            }

            // 少し遅延させて表示（即時バリデーションエラーなどで一瞬出るのを防ぐ）
            // setTimeout(() => {
            //    if (!e.defaultPrevented) { // HTMXなどでキャンセルされていなければ
            //        loadingOverlay.classList.add('active');
            //    }
            // }, 50);
            
            // 今回はシンプルに、即時表示させる（ユーザー体験優先）
            // ただし、HTMXで処理される場合は重複処理になるが、class追加は冪等なのでOK。
            // 問題は「HTMX以外で、ページ遷移を伴う送信」の場合、ページ遷移まで出しっぱなしでOK。
            
            // htmx属性がついていないフォームの場合のみここで発火させる手もあるが、
            // 判定が複雑になるので、一旦すべてのsubmitで表示し、
            // htmxの場合は afterRequest で消える、という挙動に任せる。
            // 通常のPOST遷移なら、次のページが読み込まれるまで出しっぱなしで良い。
            
            loadingOverlay.classList.add('active');
        });

        // ページバック時のキャッシュ対策 (Safariなど)
        window.addEventListener('pageshow', function(event) {
            if (event.persisted) {
                loadingOverlay.classList.remove('active');
            }
        });

        // htmx エラーハンドリング
        document.body.addEventListener('htmx:responseError', function(evt) {
            const xhr = evt.detail.xhr;
            let message = 'エラーが発生しました';
            
            try {
                const response = JSON.parse(xhr.responseText);
                message = response.detail || message;
            } catch (e) {
                // JSONでない場合はステータステキストを使用
                message = `エラー: ${xhr.status} ${xhr.statusText}`;
            }
            
            showToast(message, 'error');
        });

        // 成功通知（カスタムイベント用）
        document.body.addEventListener('show-toast', function(evt) {
            showToast(evt.detail.message, evt.detail.type || 'success');
        });
    </script>

    {% block scripts %}{% endblock %}
</body>

</html>